<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Patrón de cubos 3D — ZR con hold para cambiar SVGs y tamaño</title>
<style>
  :root{
    --scene-size: 96px;    /* tamaño del contenedor del cubo */
    --cube-size: 64px;     /* tamaño base de la cara del cubo */
    --dot-size: 2px;       /* diámetro del punto base */
  }
  html,body{height:100%;margin:0}
  body{
    background: radial-gradient(circle at center, #fafafa 0%, #d9d9d9 100%);
    overflow:hidden;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
  }

  #stage{ position:fixed; inset:0; overflow:hidden; }

  .dot{
    position:absolute;
    width: var(--dot-size);
    height: var(--dot-size);
    margin: calc(var(--dot-size)/-2) 0 0 calc(var(--dot-size)/-2);
    border-radius:50%;
    background:#777;
    opacity:.55;
    pointer-events:none;
  }

  .scene{
    position:absolute;
    width: var(--scene-size);
    height: var(--scene-size);
    margin: calc(var(--scene-size)/-2) 0 0 calc(var(--scene-size)/-2);
    perspective: 800px;
    pointer-events:none; /* todo manejo es global */
  }

  .pivot{
    position:absolute; inset:0;
    transform-style: preserve-3d;
    transform-origin: 50% 50% 0;
    will-change: transform;
    /* cada pivot puede sobreescribir --cube-size cuando está en 'alt' */
  }

  .cube{
    position:absolute; inset:0;
    transform-style: preserve-3d;
  }

  /* Caras SOLO con SVGs (usamos var(--cube-size) para que cambie por pivot) */
  .cube.inner .face{
    position:absolute;
    width: var(--cube-size);
    height: var(--cube-size);
    top:50%; left:50%;
    margin: calc(var(--cube-size)/-2) 0 0 calc(var(--cube-size)/-2);
    background-repeat:no-repeat;
    background-size:cover;
    background-position:center;
    backface-visibility:hidden;
    transform-style:preserve-3d;
    transition:
    width 0.25s ease,
    height 0.25s ease,
    margin 0.25s ease,
    transform 0.25s ease,
    background-image 0.5s ease; /* <- suaviza cambio de textura */
  }

  /* Z = mitad del tamaño de la cara */
  .inner .front  { background-image:url("face-front.svg"); transform: translateZ(calc(var(--cube-size)/2)); }
  .inner .back   { background-image:url("face-back.svg");  transform: rotateY(180deg) translateZ(calc(var(--cube-size)/2)); }
  .inner .right  { background-image:url("face-rigth.svg"); transform: rotateY( 90deg) translateZ(calc(var(--cube-size)/2)); }
  .inner .left   { background-image:url("face-left.svg");  transform: rotateY(-90deg) translateZ(calc(var(--cube-size)/2)); }
  .inner .top    { background-image:url("face-sup.svg");   transform: rotateX( 90deg) translateZ(calc(var(--cube-size)/2)); }
  .inner .bottom { background-image:url("face-down.svg");  transform: rotateX(-90deg) translateZ(calc(var(--cube-size)/2)); }

  /* Estado ALT (solo para pivots dentro de ZR y mousedown):
     - Cambia a versiones *-2.svg
     - Reduce --cube-size a 60px (afecta posiciones y translateZ)
  */
  .pivot.alt { --cube-size: 60px; }
  .pivot.alt .inner .front  { background-image:url("face-front-2.svg"); }
  .pivot.alt .inner .back   { background-image:url("face-back-2.svg");  }
  .pivot.alt .inner .right  { background-image:url("face-rigth-2.svg"); }
  .pivot.alt .inner .left   { background-image:url("face-left-2.svg");  }
  .pivot.alt .inner .top    { background-image:url("face-sup-2.svg");   }
  .pivot.alt .inner .bottom { background-image:url("face-down-2.svg");  }

  /* Zona de reacción visible (diámetro 300px -> radio 150px) */
  .zone{
    position:fixed; width:300px; height:300px;
    margin:-150px 0 0 -150px; /* centrada en el cursor */
    border:1px dashed #333; border-radius:50%;
    pointer-events:none; mix-blend-mode:multiply; opacity:.75;
  }
</style>
</head>
<body>
<div id="stage"></div>
<div class="zone" id="zone"></div>

<script>
(function(){
  // ===== Parámetros =====
  const SCENE_SIZE   = 96;   // px (match --scene-size)
  const STEP         = 90;   // separación entre puntos
  const RADIUS       = 150;  // radio 150px (ZR 300px de diámetro)
  const ROTATE_MAX_X = 45;   // pitch máximo
  const ROTATE_MAX_Y = 45;   // yaw máximo
  const ROT_SMOOTH   = 0.10; // suavizado de rotación

  const stage = document.getElementById('stage');
  const zone  = document.getElementById('zone');

  let mouse = { x: window.innerWidth/2, y: window.innerHeight/2 };
  let isDown = false; // click/hold global
  let items = []; // {pivot,dot,x0,y0, rx,ry, rxi,ryi}

  function createItem(x,y){
    // punto
    const dot = document.createElement('div');
    dot.className = 'dot';
    dot.style.left = x + 'px';
    dot.style.top  = y + 'px';
    stage.appendChild(dot);

    // scene
    const scene = document.createElement('div');
    scene.className = 'scene';
    scene.style.left = x + 'px';
    scene.style.top  = y + 'px';
    stage.appendChild(scene);

    // pivot (solo rotación)
    const pivot = document.createElement('div');
    pivot.className = 'pivot';
    scene.appendChild(pivot);

    // cubo
    const cube = document.createElement('div');
    cube.className = 'cube inner';
    cube.innerHTML = `
      <div class="face front"></div>
      <div class="face back"></div>
      <div class="face right"></div>
      <div class="face left"></div>
      <div class="face top"></div>
      <div class="face bottom"></div>
    `;
    pivot.appendChild(cube);

    // Rotación inicial frontal (cara frontal al frente)
    const rxi = 0, ryi = 0;

    return { pivot, dot, x0:x, y0:y, rx:rxi, ry:ryi, rxi, ryi };
  }

  function build(){
    stage.innerHTML = '';
    items = [];
    const w = window.innerWidth;
    const h = window.innerHeight;
    const startX = Math.floor((-STEP) / STEP) * STEP;
    const startY = Math.floor((-STEP) / STEP) * STEP;
    for(let y = startY; y < h + STEP; y += STEP){
      for(let x = startX; x < w + STEP; x += STEP){
        items.push(createItem(x,y));
      }
    }
  }

  // Eventos de puntero (soporta mouse y touch stylus)
  window.addEventListener('pointerdown', e=>{
    isDown = true;
    mouse.x = e.clientX; mouse.y = e.clientY;
    zone.style.left = mouse.x + 'px';
    zone.style.top  = mouse.y + 'px';
  }, { passive:true });

  window.addEventListener('pointerup', ()=>{
    isDown = false;
    // Al soltar, quitamos 'alt' de todos para volver a normal
    for(const it of items) it.pivot.classList.remove('alt');
  }, { passive:true });

  window.addEventListener('pointercancel', ()=>{
    isDown = false;
    for(const it of items) it.pivot.classList.remove('alt');
  }, { passive:true });

  window.addEventListener('pointermove', e=>{
    mouse.x = e.clientX; mouse.y = e.clientY;
    zone.style.left = mouse.x + 'px';
    zone.style.top  = mouse.y + 'px';
  }, { passive:true });

  function animate(){
    for(const it of items){
      const dx = mouse.x - it.x0;
      const dy = mouse.y - it.y0;
      const dist = Math.hypot(dx,dy);

      if(dist <= RADIUS){
        // falloff radial: centro => 1, borde => 0
        let falloff = 1 - (dist / RADIUS);
        if (falloff < 0) falloff = 0;
        else if (falloff > 1) falloff = 1;

        // Rotación objetivo con falloff (solo rota, no traslada)
        const nx = dx / (SCENE_SIZE/2);
        const ny = dy / (SCENE_SIZE/2);
        const targetRY =  nx * ROTATE_MAX_Y * falloff; // yaw
        const targetRX = -ny * ROTATE_MAX_X * falloff; // pitch

        it.rx += (targetRX - it.rx) * ROT_SMOOTH;
        it.ry += (targetRY - it.ry) * ROT_SMOOTH;

        // Si está presionado (hold), activar estado ALT (cambia SVGs y reduce a 60px)
        if (isDown) {
          it.pivot.classList.add('alt');
        } else {
          it.pivot.classList.remove('alt');
        }
      } else {
        // fuera de ZR: volver a frontal y quitar ALT
        it.rx += (it.rxi - it.rx) * ROT_SMOOTH;
        it.ry += (it.ryi - it.ry) * ROT_SMOOTH;
        it.pivot.classList.remove('alt');
      }

      it.pivot.style.transform =
        `rotateX(${it.rx}deg) rotateY(${it.ry}deg)`;
    }
    requestAnimationFrame(animate);
  }

  build();
  // centra la ZR inicialmente
  zone.style.left = window.innerWidth/2 + 'px';
  zone.style.top  = window.innerHeight/2 + 'px';
  animate();
})();
</script>
</body>
</html>
